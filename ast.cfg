# * is a single child
# ** is a list of children!
# int a,b,c,d; 
# Got an idea from https://github.acom/eliben/pycparser/blob/master/pycparser/_c_ast.cfg
FuncDecl:[ParamList**]{}
FuncDef: [ParamList**]{}
FuncCall: [ParamList**]{}
Return: [expr*]{}

ParamList: [params**] {}


# name: the variable being declared
# quals: list of qualifiers (const, volatile)
# storage: list of storage specifiers (extern, register, etc.)
# type: declaration type (probably nested with all the modifiers)
# init: initialization value, or None
# bitsize: bit field size, or None
Decl: [name,quals,storage,type*,init*,bitsize*] {}

DeclList: [decls**] {}

# For,while,do while
IterStatement: [init*, cond*, next*, stmt*,isdowhile] {}

# Nothing?!
Break: [] {}
Continue: [] {}

# ArrayDecl is a nested declaration of an array with the given type.
# dim: the dimension (for example, constant 42)
ArrDecl: [type*,dim*] {}

ArrRef: [name*,subscript*] {}
PtrDecl: [quals,type*] {}

Assignment: [op,lvalue*,rvalue*] {}

# &,|,<<,>>,^ 
BinOp: [op,left*,right*] {}

# cond ? true case : false case
TernaryOp: [cond*,truecond*,falsecond*] {}
If: [cond*,truecond*,falsecond*] {}

# +,-,*,/...
UnaryOp: [op,expr*] {}

Goto: [name] {}

Cast: [to_type*,expr*] {}

Constant: [type,value] {}

# Compound Statement is consumed in this
ExprList: [exprs**] {}

# Empty Statement ;
EmptyStatement: [] {}

# a list of stuff compound literals
InitList: [exprs**] {}

Label: [name,stmt*] {}	

#-- typedef and Types
# regular types
TypeDecl: [declname,quals,type*] {}

# typedefs!
TypeDef: [name,quals,storage,type*]

# struct and unions
TypeName: [name,quals,type*] {}


#--- Do Later
Struct: [name,decls**] {}
Union: [name,decls**] {}
StructRef: [name*,type,field*] {}
Case: [expr*,stmts**] {}
Default: [stmts**] {}
Switch: [cond*,stmt*] {}