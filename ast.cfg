# * is a single child
# ** is a list of children!
# int a,b,c,d; 
# Got an idea from https://github.acom/eliben/pycparser/blob/master/pycparser/_c_ast.cfg
FuncDecl:[ParamList**]{}
FuncDef: [ParamList**]{}
FuncCall: [type*,ParamList**]{}
Return: [expr*]{}

# This is used when a variable is referenced and not declared
VariableCall: [type*, name]{}

ParamList: [params**] {}


# name: the variable being declared
# type: declaration type (probably nested with all the modifiers)
# init: initialization value, or None
# bitsize: bit field size, or None
Decl: [name,type*,init*] {}

DeclList: [decls**] {}

# For,while,do while
IterStatement: [init*, cond*, next*, stmt*,isdowhile] {}

# Nothing?!
Break: [] {}
Continue: [] {}

# ArrayDecl is a nested declaration of an array with the given type.
# dim: the dimension (for example, constant 42)
ArrDecl: [type*,dim*] {}

ArrRef: [name*,subscript*] {}
PtrDecl: [quals,type*] {}

Assignment: [op,lvalue*,rvalue*] {}

# &,|,<<,>>,^ 
BinOp: [op,left*,right*] {}

# cond ? true case : false case
TernaryOp: [cond*,truecond*,falsecond*] {}
If: [cond*,truecond*,falsecond*] {}

# +,-,*,/...
UnaryOp: [op,expr*] {}

Goto: [name] {}

Cast: [to_type*,expr*] {}

Constant: [type,value] {}

# Compound Statement is consumed in this
ExprList: [exprs**] {}

# Empty Statement ;
EmptyStatement: [] {}

# a list of stuff compound literals
InitList: [exprs**] {}

Label: [name,stmt*] {}	

#-- typedef and Types
Type: [type,qualifier,storage] {}

# -- Identifier
ID: [name] {}


#--- Do Later
Struct: [name,decls**] {}
Union: [name,decls**] {}
StructRef: [name*,type,field*] {}
Case: [expr*,stmts**] {}
Default: [stmts**] {}
Switch: [cond*,stmt*] {}

Example: [a**,b**] {}
